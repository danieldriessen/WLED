<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#0b0f18">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Bedside Remote">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Bedside Remote</title>
  <style>
    :root{
      --bg0:#070a10;
      --bg1:#0b0f18;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.085);
      --text:#e7eefc;
      --muted:rgba(231,238,252,.65);
      --line:rgba(255,255,255,.08);
      --accent:#5aa8ff;
      --accent2:#7cf0c9;
      --danger:#ff5a7b;
      --warn:#ffcc66;
      --shadow: 0 12px 40px rgba(0,0,0,.45);
      --r:18px;
      --tap:54px;
      --font: ui-sans-serif, -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%; width:100%}
    html{
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(90,168,255,.18), transparent 55%),
        radial-gradient(900px 600px at 90% 10%, rgba(124,240,201,.10), transparent 60%),
        radial-gradient(900px 900px at 40% 110%, rgba(255,90,123,.08), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      background-color:var(--bg0);
      overflow:hidden;
      overscroll-behavior:none;
    }
    body{
      margin:0;
      font-family:var(--font);
      color:var(--text);
      background:transparent;
      overflow:hidden;
      overscroll-behavior:none;
      -webkit-text-size-adjust: 100%;
      position:relative;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:0;
      pointer-events:none;
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(90,168,255,.18), transparent 55%),
        radial-gradient(900px 600px at 90% 10%, rgba(124,240,201,.10), transparent 60%),
        radial-gradient(900px 900px at 40% 110%, rgba(255,90,123,.08), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      background-color: var(--bg0);
      transform: translateZ(0);
    }
    .wrap{
      width:100%;
      max-width:520px;
      margin:0 auto;
      height:100%;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding: calc(env(safe-area-inset-top) + 18px) 16px calc(env(safe-area-inset-bottom) + 26px);
      position:relative;
      z-index:1;
    }
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px}
    .title{display:flex;flex-direction:column;gap:4px}
    .title h1{margin:0;font-size:20px;letter-spacing:.2px}
    .title .sub{font-size:13px;color:var(--muted);line-height:1.35}
    .hdr-right{display:flex;align-items:center;gap:10px}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;border-radius:999px;
      background:rgba(0,0,0,.22);border:1px solid var(--line);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      font-size:12px;color:var(--muted);white-space:nowrap
    }
    .iconbtn{
      width:40px;height:40px;border-radius:999px;
      display:flex;align-items:center;justify-content:center;
      border:1px solid var(--line);
      background:rgba(0,0,0,.22);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      color:rgba(231,238,252,.82);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(10px);
    }
    .iconbtn:active{transform:scale(.99)}
    .iconbtn svg{width:18px;height:18px;stroke:currentColor;fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}
    .dot{width:8px;height:8px;border-radius:50%;background:var(--danger)}
    .dot.ok{background:var(--accent2)}
    .dot.warn{background:var(--warn)}

    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      padding:14px;
      margin:12px 0;
      backdrop-filter: blur(10px);
    }
    .seg-toggle{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .seg-btn{
      height:var(--tap);
      border-radius:16px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      color:var(--text);
      font-weight:600;
      letter-spacing:.2px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:3px;
      position:relative;
      transition:transform .06s ease, background .2s ease, border-color .2s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .seg-btn .seg-name{font-weight:900;letter-spacing:.2px;font-size:16px}
    .seg-btn .seg-state{display:flex;align-items:center;justify-content:center;gap:8px}
    .seg-btn .pwrstate{font-size:11px}
    .seg-btn:active{transform:scale(.99)}
    .seg-btn.sel{
      background:linear-gradient(180deg, rgba(90,168,255,.28), rgba(90,168,255,.12));
      border-color:rgba(90,168,255,.55);
      box-shadow: 0 10px 24px rgba(90,168,255,.16);
    }

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .grid2.colorrow{grid-template-columns:1fr}
    .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
    .btn{
      height:var(--tap);
      border-radius:16px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      color:var(--text);
      font-weight:700;
      letter-spacing:.15px;
      display:flex;align-items:center;justify-content:center;
      gap:10px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.twoline{
      flex-direction:column;
      gap:3px;
      line-height:1.05;
    }
    .btn.twoline .main{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
    }
    .btn.twoline .t2{
      font-size:11px;
      font-weight:800;
      color:var(--muted);
      letter-spacing:0;
      width:100%;
      text-align:center;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      padding:0 8px;
    }
    .ico{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:22px;
      height:22px;
      border-radius:999px;
      background:rgba(0,0,0,.18);
      border:1px solid var(--line);
      color:var(--muted);
      font-weight:900;
      line-height:1;
      flex:0 0 auto;
    }
    .ico svg{width:16px;height:16px;stroke:currentColor;fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}
    .ico.warm{color: #ffcc66; border-color: rgba(255,204,102,.35); background: rgba(255,204,102,.08)}
    .ico.cool{color: #7fb7ff; border-color: rgba(127,183,255,.35); background: rgba(127,183,255,.08)}
    .btn:active{transform:scale(.99)}
    .btn.primary{
      background:linear-gradient(180deg, rgba(124,240,201,.26), rgba(124,240,201,.10));
      border-color:rgba(124,240,201,.55);
    }
    .btn.danger{
      background:linear-gradient(180deg, rgba(255,90,123,.30), rgba(255,90,123,.10));
      border-color:rgba(255,90,123,.55);
    }
    .btn.ghost{background:rgba(0,0,0,.18)}
    .btn.small{height:44px;border-radius:14px;font-weight:700}
    .btn.sel{border-color:rgba(90,168,255,.6);background:rgba(90,168,255,.16)}
    .row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:12px 0 6px}
    .row .label{font-weight:700}
    .row .hint{font-size:12px;color:var(--muted)}
    .statusline{font-size:13px;color:var(--muted);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .statusline b{color:var(--text)}

    .bri{
      display:grid;
      grid-template-columns: var(--tap) 1fr var(--tap);
      gap:10px;
      align-items:center;
      margin-top:10px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .chip{
      display:inline-flex;align-items:center;justify-content:center;
      min-width:46px;height:32px;padding:0 10px;border-radius:999px;
      background:rgba(0,0,0,.22);border:1px solid var(--line);color:var(--muted);
      font-size:12px;font-weight:700;
    }

    .pwrstate{font-size:12px;color:var(--muted);font-weight:800;white-space:nowrap}
    .pwrdot{width:10px;height:10px;border-radius:50%;background:var(--danger);flex:0 0 auto}
    .pwrdot.on{background:var(--accent2)}
    .pwrdot.anim{background:var(--warn)}

    .adv-grid{display:grid;grid-template-columns:1fr;gap:10px}
    .field{
      background:rgba(0,0,0,.16);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .field .top{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .field .top .k{font-weight:800}
    .field .top .v{font-size:12px;color:var(--muted)}
    .toggle{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
    }
    .toggle input{width:22px;height:22px}
    .footer{margin-top:12px;font-size:12px;color:var(--muted);line-height:1.4}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}

    .colorbtn{
      position:relative;
      overflow:hidden;
      justify-content:center;
      padding:0;
    }
    .swatch{
      position:absolute;
      inset:0;
      border-radius:inherit;
      border:0;
      background:#ffa000;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.18);
    }
    .colorbtn::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      pointer-events:none;
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(0,0,0,.08));
      opacity:.35;
    }
    input.color-input{
      position:absolute;
      inset:0;
      opacity:0.0001;
      width:100%;
      height:100%;
      cursor:pointer;
    }

    .modal{position:fixed;inset:0;z-index:9999}
    .modal[hidden]{display:none}
    .modal-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.55)}
    .modal-sheet{
      position:absolute;
      left:0;right:0;bottom:0;
      padding:12px 16px calc(env(safe-area-inset-bottom) + 16px);
      background:rgba(12,16,26,.94);
      border-top:1px solid rgba(255,255,255,.10);
      border-top-left-radius:22px;
      border-top-right-radius:22px;
      box-shadow:0 -18px 60px rgba(0,0,0,.55);
      max-height:85vh;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    .sheet-hdr{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:10px}
    .sheet-title{font-weight:900;letter-spacing:.2px}
    .sheet-sub{font-size:12px;color:var(--muted);margin-top:3px;line-height:1.35}
    .sheet-close{
      width:44px;height:44px;border-radius:14px;
      display:flex;align-items:center;justify-content:center;
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      color:var(--text);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .sheet-close svg{width:18px;height:18px;stroke:currentColor;fill:none;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Bedside Remote</h1>
      </div>
      <div class="hdr-right">
        <div class="pill" id="connPill" aria-live="polite">
          <span class="dot" id="connDot"></span>
          <span id="connText">Connecting…</span>
        </div>
        <div class="iconbtn" id="btnAdvanced" role="button" tabindex="0" aria-label="Settings">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.094c.55 0 1.02.398 1.11.94l.15.902c.07.424.37.778.781.93.48.175.94.395 1.37.654.37.224.84.24 1.2.02l.775-.47c.47-.287 1.08-.217 1.47.173l.773.773c.39.39.46 1 .173 1.47l-.47.775c-.22.36-.204.83.02 1.2.26.43.48.89.654 1.37.152.411.506.711.93.781l.902.15c.542.09.94.56.94 1.11v1.094c0 .55-.398 1.02-.94 1.11l-.902.15c-.424.07-.778.37-.93.781-.175.48-.395.94-.654 1.37-.224.37-.24.84-.02 1.2l.47.775c.287.47.217 1.08-.173 1.47l-.773.773c-.39.39-1 .46-1.47.173l-.775-.47c-.36-.22-.83-.204-1.2.02-.43.26-.89.48-1.37.654-.411.152-.711.506-.781.93l-.15.902c-.09.542-.56.94-1.11.94h-1.094c-.55 0-1.02-.398-1.11-.94l-.15-.902c-.07-.424-.37-.778-.781-.93-.48-.175-.94-.395-1.37-.654-.37-.224-.84-.24-1.2-.02l-.775.47c-.47.287-1.08.217-1.47-.173l-.773-.773c-.39-.39-.46-1-.173-1.47l.47-.775c.22-.36.204-.83-.02-1.2-.26-.43-.48-.89-.654-1.37-.152-.411-.506-.711-.93-.781l-.902-.15c-.542-.09-.94-.56-.94-1.11v-1.094c0-.55.398-1.02.94-1.11l.902-.15c.424-.07.778-.37.93-.781.175-.48.395-.94.654-1.37.224-.37.24-.84.02-1.2l-.47-.775c-.287-.47-.217-1.08.173-1.47l.773-.773c.39-.39 1-.46 1.47-.173l.775.47c.36.22.83.204 1.2-.02.43-.26.89-.48 1.37-.654.411-.152.711-.506.781-.93l.15-.902Z"/>
            <path d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"/>
          </svg>
        </div>
      </div>
    </header>

    <div class="card">
      <div class="seg-toggle" role="tablist" aria-label="Select bedside">
        <div class="seg-btn" id="btnDaniel" role="tab" tabindex="0">
          <div class="seg-name">Daniel</div>
          <div class="seg-state">
            <span class="pwrdot" id="pwrDanielDot" aria-hidden="true"></span>
            <span class="pwrstate" id="pwrDanielState">—</span>
          </div>
        </div>
        <div class="seg-btn" id="btnGabi" role="tab" tabindex="0">
          <div class="seg-name">Gabriela</div>
          <div class="seg-state">
            <span class="pwrdot" id="pwrGabiDot" aria-hidden="true"></span>
            <span class="pwrstate" id="pwrGabiState">—</span>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="grid2">
        <div class="btn primary" id="btnOn">ON</div>
        <div class="btn danger" id="btnOff">OFF</div>
      </div>

      <div class="row">
        <div class="label">Mode</div>
      </div>
      <div class="grid2">
        <div class="btn twoline" id="btnSideFull">
          <span class="main">
            <span class="ico" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M12 4v16"/><path d="M8 8l4-4 4 4"/><path d="M8 16l4 4 4-4"/></svg></span>
            <span class="t1">Side</span>
          </span>
          <span class="t2">Full</span>
        </div>
        <div class="btn twoline" id="btnTopFull">
          <span class="main">
            <span class="ico" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M4 12h16"/><path d="M8 8l-4 4 4 4"/><path d="M16 8l4 4-4 4"/></svg></span>
            <span class="t1">Top</span>
          </span>
          <span class="t2">Full</span>
        </div>
        <div class="btn twoline" id="btnSide">
          <span class="main">
            <span class="ico" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M12 4v16"/><path d="M8 8l4-4 4 4"/><path d="M8 16l4 4 4-4"/></svg></span>
            <span class="t1">Side</span>
          </span>
          <span class="t2">Saved Preference</span>
        </div>
        <div class="btn twoline" id="btnTop">
          <span class="main">
            <span class="ico" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M4 12h16"/><path d="M8 8l-4 4 4 4"/><path d="M16 8l4 4-4 4"/></svg></span>
            <span class="t1">Top</span>
          </span>
          <span class="t2">Saved Preference</span>
        </div>
      </div>

      <div class="row">
        <div class="label">Brightness</div>
        <div class="hint"><span class="mono" id="briVal">—</span></div>
      </div>
      <div class="bri">
        <div class="btn ghost" id="btnBriDown" aria-label="Brightness down">−</div>
        <input type="range" min="0" max="255" value="128" id="briSlider">
        <div class="btn ghost" id="btnBriUp" aria-label="Brightness up">+</div>
      </div>

      <div class="row">
        <div class="label">Size</div>
      </div>
      <div class="grid2">
        <div class="btn" id="btnLess"><span class="ico" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M5 12h14"/></svg></span>Less LEDs</div>
        <div class="btn" id="btnMore"><span class="ico" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M12 5v14"/><path d="M5 12h14"/></svg></span>More LEDs</div>
      </div>

      <div class="row">
        <div class="label">White</div>
      </div>
      <div class="grid2">
        <div class="btn" id="btnWarm"><span class="ico warm" aria-hidden="true"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="4"/><path d="M12 2v3"/><path d="M12 19v3"/><path d="M2 12h3"/><path d="M19 12h3"/><path d="M4.2 4.2l2.1 2.1"/><path d="M17.7 17.7l2.1 2.1"/><path d="M19.8 4.2l-2.1 2.1"/><path d="M6.3 17.7l-2.1 2.1"/></svg></span>Warmer</div>
        <div class="btn" id="btnCool"><span class="ico cool" aria-hidden="true"><svg viewBox="0 0 24 24"><path d="M12 2v20"/><path d="M7 6l10 12"/><path d="M17 6L7 18"/><path d="M4.5 9h15"/><path d="M4.5 15h15"/></svg></span>Colder</div>
      </div>

      <div class="row">
        <div class="label">Color</div>
      </div>
      <div class="grid2 colorrow">
        <label class="btn small colorbtn" id="colorPickBtn" aria-label="Pick color">
          <span class="swatch" id="colorSwatch" aria-hidden="true"></span>
          <input class="color-input" id="colorPick" type="color" value="#ffa000" aria-label="Pick color">
        </label>
      </div>
    </div>

  </div>

  <div class="modal" id="advModal" hidden aria-hidden="true">
    <div class="modal-backdrop" id="advBackdrop" aria-hidden="true"></div>
    <div class="modal-sheet" role="dialog" aria-modal="true" aria-label="Advanced">
      <div class="sheet-hdr">
        <div>
          <div class="sheet-title">Advanced</div>
          <div class="sheet-sub">Tuning for the selected bedside (applies to the current segment).</div>
        </div>
        <div class="sheet-close" id="advClose" role="button" tabindex="0" aria-label="Close">
          <svg viewBox="0 0 24 24"><path d="M6 6l12 12"/><path d="M18 6L6 18"/></svg>
        </div>
      </div>

      <div class="adv-grid">
        <div class="field">
          <div class="top">
            <div class="k">Expand speed</div>
            <div class="v mono" id="sxVal">sx —</div>
          </div>
          <input type="range" min="0" max="255" value="90" id="sxSlider">
        </div>

        <div class="field">
          <div class="top">
            <div class="k">Retract speed</div>
            <div class="v mono" id="ixVal">ix —</div>
          </div>
          <input type="range" min="0" max="255" value="120" id="ixSlider">
        </div>

        <div class="field">
          <div class="top">
            <div class="k">Overlap</div>
            <div class="v mono" id="c3Val">c3 —</div>
          </div>
          <input type="range" min="0" max="31" value="14" id="c3Slider">
          <div class="footer">In WLED, <span class="mono">c3</span> is 0–31. The effect maps it to ~0–80 LEDs overlap.</div>
        </div>

        <div class="field">
          <div class="toggle">
            <div>
              <div style="font-weight:800">Realistic OFF</div>
              <div class="hint">Speed-up + small brightness swell near ground</div>
            </div>
            <input type="checkbox" id="o2Chk" checked>
          </div>
        </div>

        <div class="field">
          <div class="toggle">
            <div>
              <div style="font-weight:800">No animation</div>
              <div class="hint">Instant jump to steady ON/OFF (debug)</div>
            </div>
            <input type="checkbox" id="o3Chk">
          </div>
        </div>

        <div class="field">
          <div class="toggle">
            <div>
              <div style="font-weight:800">Tight mode</div>
              <div class="hint">Use “min” windows for Top/Side buttons</div>
            </div>
            <input type="checkbox" id="tightChk">
          </div>
        </div>

        <div class="field">
          <div class="toggle">
            <div>
              <div style="font-weight:800">Persist on device</div>
              <div class="hint">Save state to your boot preset after changes</div>
            </div>
            <input type="checkbox" id="persistChk" checked>
          </div>
        </div>

        <div class="field">
          <div class="top">
            <div class="k">Current target</div>
            <div class="v mono" id="c12Val">c1/c2 —</div>
          </div>
          <div class="footer">This page drives <span class="mono">/json/state</span> for the selected segment and uses <span class="mono">o1</span> for OFF-with-animation.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const $ = (id) => document.getElementById(id);

    // Device contract (current setup on your device)
    const DEVICE = {
      ipHint: location.host || "192.168.2.80",
      segments: {
        daniel: { id: 0, name: "Daniel",   fx: 219, len: 131, groundAtStart: true  },
        gabi:   { id: 1, name: "Gabriela", fx: 218, len: 131, groundAtStart: false },
      },
      // Anchor ranges (segment-local indices, inclusive)
      // Right (Daniel): local == global for 0..130
      // Left (Gabriela): derived by mirror rule then converted to segment-local (global-131)
      anchors: {
        daniel: {
          topMin:  [108,116],
          topMax:  [78,130],
          sideMin: [23,31],
          sideMax: [15,77],
        },
        gabi: {
          topMin:  [14,22],
          topMax:  [0,52],
          sideMin: [99,107],
          sideMax: [53,115],
        }
      }
    };

    const ui = {
      connPill: $("connPill"), connDot: $("connDot"), connText: $("connText"),
      btnDaniel: $("btnDaniel"), btnGabi: $("btnGabi"),
      pwrDanielDot: $("pwrDanielDot"), pwrGabiDot: $("pwrGabiDot"),
      pwrDanielState: $("pwrDanielState"), pwrGabiState: $("pwrGabiState"),
      btnOn: $("btnOn"), btnOff: $("btnOff"),
      btnBriDown: $("btnBriDown"), btnBriUp: $("btnBriUp"), briSlider: $("briSlider"), briVal: $("briVal"),
      btnMore: $("btnMore"), btnLess: $("btnLess"),
      btnSide: $("btnSide"), btnTop: $("btnTop"), btnSideFull: $("btnSideFull"), btnTopFull: $("btnTopFull"),
      btnWarm: $("btnWarm"), btnCool: $("btnCool"),
      colorPick: $("colorPick"), colorSwatch: $("colorSwatch"),
      btnAdvanced: $("btnAdvanced"),
      advModal: $("advModal"), advBackdrop: $("advBackdrop"), advClose: $("advClose"),
      sxSlider: $("sxSlider"), ixSlider: $("ixSlider"), c3Slider: $("c3Slider"),
      sxVal: $("sxVal"), ixVal: $("ixVal"), c3Val: $("c3Val"),
      o2Chk: $("o2Chk"), o3Chk: $("o3Chk"), tightChk: $("tightChk"), persistChk: $("persistChk"),
      c12Val: $("c12Val"),
    };

    const LS_KEY = "bedsideRemote.selected";
    const LS_MODE_PREFIX = "bedsideRemote.mode.";
    const LS_MODEVAR_PREFIX = "bedsideRemote.modeVar.";
    const LS_MEM_PREFIX  = "bedsideRemote.mem.";
    const LS_STEP_PREFIX = "bedsideRemote.step.";
    const LS_PERSIST_KEY = "bedsideRemote.persistBootPreset";
    const LS_LASTWHITE_PREFIX = "bedsideRemote.lastWhite.";
    let selectedKey = localStorage.getItem(LS_KEY) || "daniel";
    let selectedModeBySide = {
      daniel: localStorage.getItem(LS_MODE_PREFIX + "daniel") || "side",
      gabi:   localStorage.getItem(LS_MODE_PREFIX + "gabi")   || "side",
    };
    let modeVariantBySide = {
      daniel: localStorage.getItem(LS_MODEVAR_PREFIX + "daniel") || "saved",
      gabi:   localStorage.getItem(LS_MODEVAR_PREFIX + "gabi")   || "saved",
    }; // "saved" | "full"
    let lastState = null;
    let pollTimer = null;
    let busy = false;
    let suppressTuningFromStateUntil = 0;
    let bootPresetId = null;
    let bootPresetName = null;
    let persistTimer = null;
    let suppressColorFromStateUntil = 0;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const briToPct = (bri) => `${Math.round(clamp(bri ?? 0, 0, 255) * 100 / 255)} %`;
    const encIdx = (idx, len) => {
      if (len <= 1) return 0;
      return Math.round(idx * 255 / (len - 1));
    };
    const decIdx = (u8, len) => {
      if (len <= 1) return 0;
      return Math.round(u8 * (len - 1) / 255);
    };

    // Canonical "More/Less LEDs" behavior:
    // step through a fixed ordered list of inclusive ranges per side+mode (clamped at ends; no wrap-around).
    function genPhaseSym(a0, b0, steps) {
      const out = [];
      for (let k = 0; k < steps; k++) out.push([a0 - k, b0 + k]);
      return out;
    }
    function genPhaseFixedHi(hi, aStart, aEndInclusive) {
      const out = [];
      for (let a = aStart; a >= aEndInclusive; a--) out.push([a, hi]);
      return out;
    }
    function genPhaseFixedLo(lo, bStart, bEndInclusive) {
      const out = [];
      for (let b = bStart; b <= bEndInclusive; b++) out.push([lo, b]);
      return out;
    }
    function toLocalRanges(rangesGlobal, sideKey) {
      const off = (sideKey === "gabi") ? 131 : 0;
      const len = DEVICE.segments[sideKey].len;
      return rangesGlobal.map(([a, b]) => {
        const lo = clamp(a - off, 0, len - 1);
        const hi = clamp(b - off, 0, len - 1);
        return [Math.min(lo, hi), Math.max(lo, hi)];
      });
    }
    const STEP_LISTS = (() => {
      // Global step lists (inclusive indices). These match the canonical spec in your prompt.
      const rightSideGlobal = [
        ...genPhaseSym(23, 31, 9),
        ...genPhaseFixedLo(15, 40, 77),
      ];
      const rightTopGlobal = [
        ...genPhaseSym(108, 116, 15),
        ...genPhaseFixedHi(130, 93, 78),
      ];
      const leftSideGlobal = [
        ...genPhaseSym(230, 238, 9),
        ...genPhaseFixedHi(246, 221, 184),
      ];
      const leftTopGlobal = [
        ...genPhaseSym(145, 153, 15),
        ...genPhaseFixedLo(131, 168, 183),
      ];

      return {
        daniel: {
          side: toLocalRanges(rightSideGlobal, "daniel"),
          top:  toLocalRanges(rightTopGlobal,  "daniel"),
        },
        gabi: {
          side: toLocalRanges(leftSideGlobal, "gabi"),
          top:  toLocalRanges(leftTopGlobal,  "gabi"),
        }
      };
    })();

    function selected() {
      return DEVICE.segments[selectedKey];
    }

    function modeKeyForSide(sideKey) {
      return selectedModeBySide[sideKey] || "side";
    }

    function setModeForSide(sideKey, mode) {
      selectedModeBySide[sideKey] = mode;
      localStorage.setItem(LS_MODE_PREFIX + sideKey, mode);
    }

    function memKey(sideKey, mode) {
      return `${LS_MEM_PREFIX}${sideKey}.${mode}`;
    }
    function stepKey(sideKey, mode) {
      return `${LS_STEP_PREFIX}${sideKey}.${mode}`;
    }

    function readMem(sideKey, mode) {
      try {
        const raw = localStorage.getItem(memKey(sideKey, mode));
        return raw ? JSON.parse(raw) : null;
      } catch {
        return null;
      }
    }

    function writeMem(sideKey, mode, obj) {
      try {
        localStorage.setItem(memKey(sideKey, mode), JSON.stringify(obj));
      } catch {
        // ignore quota / serialization errors
      }
    }
    function readStepIndex(sideKey, mode) {
      const raw = localStorage.getItem(stepKey(sideKey, mode));
      const n = raw == null ? NaN : parseInt(raw, 10);
      return Number.isFinite(n) ? n : null;
    }
    function writeStepIndex(sideKey, mode, idx) {
      try { localStorage.setItem(stepKey(sideKey, mode), String(idx)); } catch {}
    }

    function segPrimaryCol(seg) {
      const c = seg?.col?.[0];
      if (!Array.isArray(c) || c.length < 3) return null;
      return [c[0] ?? 0, c[1] ?? 0, c[2] ?? 0, c[3] ?? 0].map(v => clamp(parseInt(v, 10) || 0, 0, 255));
    }

    function rgbToHex(r,g,b) {
      const h = (n) => clamp(n,0,255).toString(16).padStart(2,"0");
      return `#${h(r)}${h(g)}${h(b)}`;
    }
    function hexToRgb(hex) {
      const v = String(hex || "").trim().replace("#", "");
      if (v.length !== 6) return null;
      const r = parseInt(v.slice(0,2), 16);
      const g = parseInt(v.slice(2,4), 16);
      const b = parseInt(v.slice(4,6), 16);
      if (![r,g,b].every(Number.isFinite)) return null;
      return [clamp8(r), clamp8(g), clamp8(b), 0];
    }
    function setSwatch(hex) {
      if (!ui.colorSwatch) return;
      ui.colorSwatch.style.background = hex || "#ffa000";
    }

    function currentColorOrDefault() {
      const seg = getSegFromState(lastState, selected().id);
      return segPrimaryCol(seg) || [255,160,0,0];
    }

    function clamp8(v) { return clamp(v|0, 0, 255); }

    function mix(a, b, t01) {
      return clamp8(Math.round(a + (b - a) * t01));
    }

    const WHITE_REF_WARM = [255,160,0,0];
    const WHITE_REF_COOL = [170,215,255,0];
    function distToWhiteTrack(rgb) {
      // "White track" is the line segment between warm and cool reference whites.
      // If current color is off-track (e.g. RGB accent), Warmer/Colder should first restore the last white-track color.
      const ax = WHITE_REF_WARM[0], ay = WHITE_REF_WARM[1], az = WHITE_REF_WARM[2];
      const bx = WHITE_REF_COOL[0], by = WHITE_REF_COOL[1], bz = WHITE_REF_COOL[2];
      const px = rgb[0], py = rgb[1], pz = rgb[2];
      const abx = bx - ax, aby = by - ay, abz = bz - az;
      const apx = px - ax, apy = py - ay, apz = pz - az;
      const ab2 = abx*abx + aby*aby + abz*abz;
      let t = ab2 > 0 ? (apx*abx + apy*aby + apz*abz) / ab2 : 0;
      if (t < 0) t = 0;
      if (t > 1) t = 1;
      const qx = ax + abx*t, qy = ay + aby*t, qz = az + abz*t;
      const dx = px - qx, dy = py - qy, dz = pz - qz;
      return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }
    function isOnWhiteTrack(rgb) {
      // Threshold tuned for "close enough" to our warm↔cool axis without false positives for saturated RGB colors.
      return distToWhiteTrack(rgb) <= 18;
    }
    function lastWhiteKey(sideKey) {
      return `${LS_LASTWHITE_PREFIX}${sideKey}`;
    }
    function readLastWhite(sideKey) {
      const raw = localStorage.getItem(lastWhiteKey(sideKey));
      return raw ? hexToRgb(raw) : null;
    }
    function writeLastWhite(sideKey, rgb) {
      try { localStorage.setItem(lastWhiteKey(sideKey), rgbToHex(rgb[0], rgb[1], rgb[2])); } catch {}
    }
    function maybeTrackWhite(sideKey, rgb) {
      if (isOnWhiteTrack(rgb)) writeLastWhite(sideKey, rgb);
    }
    function stepWarmerColder(dir, cur /* rgb */) {
      // Use a small step towards a warm/cool reference white.
      // This keeps user-chosen brightness and only nudges hue/temperature.
      const step = 0.10; // per-tap blend factor (smaller = finer steps)
      const ref = (dir > 0) ? WHITE_REF_WARM : WHITE_REF_COOL;
      return [
        mix(cur[0], ref[0], step),
        mix(cur[1], ref[1], step),
        mix(cur[2], ref[2], step),
        0
      ];
    }

    function snapshotForLightbar(seg) {
      if (!seg) return null;
      if (typeof seg.c1 !== "number" || typeof seg.c2 !== "number") return null;
      return {
        c1: seg.c1,
        c2: seg.c2,
      };
    }

    function currentRangeLocalForSideMode(sideKey, mode) {
      const segId = DEVICE.segments[sideKey]?.id;
      const fxId  = DEVICE.segments[sideKey]?.fx;
      const len   = DEVICE.segments[sideKey]?.len ?? 1;
      const list  = STEP_LISTS?.[sideKey]?.[mode] || [];

      const seg = getSegFromState(lastState, segId);
      if (seg && seg.fx === fxId && typeof seg.c1 === "number" && typeof seg.c2 === "number") {
        const a = decIdx(seg.c1, len);
        const b = decIdx(seg.c2, len);
        return { lo: Math.min(a,b), hi: Math.max(a,b) };
      }

      const mem = readMem(sideKey, mode);
      if (mem && typeof mem.c1 === "number" && typeof mem.c2 === "number") {
        const a = decIdx(mem.c1, len);
        const b = decIdx(mem.c2, len);
        return { lo: Math.min(a,b), hi: Math.max(a,b) };
      }

      if (list.length) {
        const [lo, hi] = list[0];
        return { lo, hi };
      }

      return { lo: 0, hi: 0 };
    }

    function bestStepIndexForRange(list, lo, hi) {
      if (!list.length) return 0;
      let best = 0;
      let bestScore = Infinity;
      for (let i = 0; i < list.length; i++) {
        const [a, b] = list[i];
        if (a === lo && b === hi) return i;
        const score = Math.abs(a - lo) + Math.abs(b - hi);
        if (score < bestScore) { bestScore = score; best = i; }
      }
      return best;
    }

    function rememberCurrentForSideMode(sideKey, mode) {
      if (!lastState) return;
      const segId = DEVICE.segments[sideKey]?.id;
      const fxId  = DEVICE.segments[sideKey]?.fx;
      const seg = getSegFromState(lastState, segId);
      if (!seg || seg.fx !== fxId) return; // only remember Lightbar settings for Lightbar modes
      const snap = snapshotForLightbar(seg);
      if (!snap) return;
      writeMem(sideKey, mode, snap);
    }

    function reflectModeUIForSelected() {
      const mode = modeKeyForSide(selectedKey);
      const variant = modeVariantBySide[selectedKey] || "saved";
      const saved = (variant !== "full");

      ui.btnTop.classList.toggle("sel", mode === "top" && saved);
      ui.btnSide.classList.toggle("sel", mode === "side" && saved);
      ui.btnTopFull.classList.toggle("sel", mode === "top" && !saved);
      ui.btnSideFull.classList.toggle("sel", mode === "side" && !saved);
    }

    function isFullVariant(sideKey) {
      return (modeVariantBySide[sideKey] || "saved") === "full";
    }

    function setModeVariantForSide(sideKey, variant) {
      const v = (variant === "full") ? "full" : "saved";
      modeVariantBySide[sideKey] = v;
      localStorage.setItem(LS_MODEVAR_PREFIX + sideKey, v);
    }

    function setSelected(key) {
      // Before switching, remember the last-used state into the current mode of the previous side.
      if (key !== selectedKey) {
        if (!isFullVariant(selectedKey)) rememberCurrentForSideMode(selectedKey, modeKeyForSide(selectedKey));
      }

      selectedKey = key;
      localStorage.setItem(LS_KEY, key);
      ui.btnDaniel.classList.toggle("sel", key === "daniel");
      ui.btnGabi.classList.toggle("sel", key === "gabi");
      reflectModeUIForSelected();
      renderFromState(lastState);
    }

    async function postJson(payload) {
      const res = await fetch("/json/state", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json().catch(() => ({}));
    }

    async function postState(segObj) {
      return await postJson({ seg: [segObj] });
    }

    function conn(ok, txt, level="ok") {
      ui.connDot.classList.toggle("ok", ok);
      ui.connDot.classList.toggle("warn", level==="warn" && ok);
      ui.connText.textContent = txt;
    }

    function getSegFromState(state, segId) {
      if (!state || !state.seg) return null;
      return state.seg.find(s => s.id === segId) || null;
    }

    function renderFromState(state) {
      if (!state) return;
      const sSel = selected();
      const segSel = getSegFromState(state, sSel.id);
      if (!segSel) return;

      const now = Date.now();
      const allowTuningFromState = now >= suppressTuningFromStateUntil;
      const allowColorFromState  = allowTuningFromState && now >= suppressColorFromStateUntil;
      const notActive = (el) => document.activeElement !== el;

      // Brightness
      if (allowTuningFromState && notActive(ui.briSlider) && typeof segSel.bri === "number") {
        ui.briSlider.value = segSel.bri;
      }
      ui.briVal.textContent = briToPct(parseInt(ui.briSlider.value, 10));

      // Advanced tuning (sx/ix/c3 + o2/o3)
      if (allowTuningFromState && notActive(ui.sxSlider) && typeof segSel.sx === "number") ui.sxSlider.value = segSel.sx;
      if (allowTuningFromState && notActive(ui.ixSlider) && typeof segSel.ix === "number") ui.ixSlider.value = segSel.ix;
      if (allowTuningFromState && notActive(ui.c3Slider) && typeof segSel.c3 === "number") ui.c3Slider.value = segSel.c3;

      ui.sxVal.textContent = `sx ${ui.sxSlider.value}`;
      ui.ixVal.textContent = `ix ${ui.ixSlider.value}`;
      ui.c3Val.textContent = `c3 ${ui.c3Slider.value}`;
      ui.c12Val.textContent = `c1 ${segSel.c1 ?? "—"} • c2 ${segSel.c2 ?? "—"}`;

      if (allowTuningFromState && notActive(ui.o2Chk)) ui.o2Chk.checked = !!segSel.o2;
      if (allowTuningFromState && notActive(ui.o3Chk)) ui.o3Chk.checked = !!segSel.o3;

      // Color picker preview (reflect current segment primary color when idle)
      if (allowColorFromState && notActive(ui.colorPick)) {
        const c0 = segPrimaryCol(segSel);
        if (c0) {
          const hex = rgbToHex(c0[0], c0[1], c0[2]);
          if (ui.colorPick.value !== hex) ui.colorPick.value = hex;
          setSwatch(hex);
        }
      } else {
        setSwatch(ui.colorPick.value);
      }

      function setPwrUI(sideKey, dotEl, stateEl) {
        const cfg = DEVICE.segments[sideKey];
        const seg = getSegFromState(state, cfg.id);
        if (!seg) {
          dotEl.classList.remove("on","anim");
          stateEl.textContent = "—";
          return;
        }
        const isLightbar = (seg.fx === cfg.fx);
        const on = !!seg.on;
        const desired = !!seg.o1;
        let label = "OFF";
        dotEl.classList.remove("on","anim");

        if (isLightbar) {
          if (on && desired) { label = "ON"; dotEl.classList.add("on"); }
          else if (on && !desired) { label = "OFF (anim)"; dotEl.classList.add("anim"); }
          else { label = "OFF"; }
        } else {
          if (on) { label = "ON"; dotEl.classList.add("on"); }
          else { label = "OFF"; }
        }
        stateEl.textContent = label;
      }

      setPwrUI("daniel", ui.pwrDanielDot, ui.pwrDanielState);
      setPwrUI("gabi",   ui.pwrGabiDot,   ui.pwrGabiState);
    }

    async function pollOnce() {
      try {
        const res = await fetch("/json/state", { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        lastState = await res.json();
        conn(true, "Connected", "ok");
        renderFromState(lastState);
      } catch (e) {
        conn(false, "Offline");
      }
    }

    async function initBootPresetInfo() {
      try {
        const res = await fetch("/json/info", { cache: "no-store" });
        if (!res.ok) return;
        const info = await res.json();
        const bps = info?.leds?.bootps;
        if (typeof bps === "number" && bps > 0 && bps < 251) bootPresetId = bps;
      } catch {}

      if (!bootPresetId) return;

      try {
        const res = await fetch("/presets.json", { cache: "no-store" });
        if (!res.ok) return;
        const presets = await res.json();
        const p = presets[String(bootPresetId)] || presets[bootPresetId];
        if (p && typeof p.n === "string" && p.n.length) bootPresetName = p.n;
      } catch {}
    }

    function persistEnabled() {
      return !!ui.persistChk?.checked && !!bootPresetId;
    }

    async function persistToBootPresetNow() {
      if (!persistEnabled()) return;
      const payload = { psave: bootPresetId, ib: 1, sb: 1 };
      if (bootPresetName) payload.n = bootPresetName;
      await postJson(payload);
    }

    function schedulePersistToBootPreset() {
      if (!persistEnabled()) return;
      if (isFullVariant(selectedKey)) return; // never persist "Full" windows
      if (persistTimer) clearTimeout(persistTimer);
      persistTimer = setTimeout(async () => {
        // Do NOT call safeAction() here (that would re-schedule persist and loop).
        try {
          // If user is currently changing something, postpone.
          if (busy) { schedulePersistToBootPreset(); return; }
          await persistToBootPresetNow();
        } catch {}
      }, 1500);
    }

    function startPolling() {
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(pollOnce, 900);
      pollOnce();
    }

    async function safeAction(fn, opts = {}) {
      if (busy) return;
      busy = true;
      try { await fn(); }
      finally { busy = false; }
      await pollOnce();
      // Keep per-mode memory updated for the selected side, based on the current selected mode.
      if (opts.remember !== false && !isFullVariant(selectedKey)) rememberCurrentForSideMode(selectedKey, modeKeyForSide(selectedKey));
      if (opts.persist !== false && !isFullVariant(selectedKey)) schedulePersistToBootPreset();
    }

    function currentTuning() {
      return {
        sx: parseInt(ui.sxSlider.value, 10),
        ix: parseInt(ui.ixSlider.value, 10),
        c3: parseInt(ui.c3Slider.value, 10),
        o2: !!ui.o2Chk.checked,
        o3: !!ui.o3Chk.checked,
      };
    }

    function userAdjustingTuning() {
      suppressTuningFromStateUntil = Date.now() + 1400;
    }

    function openAdvanced() {
      ui.advModal.hidden = false;
      ui.advModal.setAttribute("aria-hidden", "false");
      // keep focus on close for easy dismissal
      setTimeout(() => ui.advClose?.focus?.(), 0);
    }
    function closeAdvanced() {
      ui.advModal.hidden = true;
      ui.advModal.setAttribute("aria-hidden", "true");
    }

    async function applyTuningFromUI() {
      const s = selected();
      const t = currentTuning();
      await postState({ id: s.id, ...t });
    }

    function currentC12FromStateOrDefault() {
      const seg = getSegFromState(lastState, selected().id);
      if (seg && typeof seg.c1 === "number" && typeof seg.c2 === "number") return { c1: seg.c1, c2: seg.c2 };
      return { c1: 128, c2: 128 };
    }

    async function turnOn() {
      const s = selected();
      if (!lastState) await pollOnce(); // ensure we restore the latest per-segment state

      const seg = getSegFromState(lastState, s.id);

      // Restore last-used state:
      // - Always turn the segment ON (seg.on=true)
      // - Only use the Lightbar virtual power contract (o1=true) if the segment is currently on the Lightbar effect.
      // - If the segment isn't set up yet (missing in state), initialize it to the expected Lightbar effect for this side.
      if (!seg) {
        const { c1, c2 } = currentC12FromStateOrDefault();
        const t = currentTuning();
        await postState({ id: s.id, on: true, fx: s.fx, o1: true, ...t, c1, c2 });
        return;
      }

      if (seg.fx === s.fx) {
        await postState({ id: s.id, on: true, o1: true });
        return;
      }

      // Different effect active -> do not force Lightbar or its o1 semantics.
      await postState({ id: s.id, on: true });
    }

    async function turnOff() {
      const s = selected();
      if (!lastState) await pollOnce();

      const seg = getSegFromState(lastState, s.id);

      // If the segment is running the Lightbar effect, request OFF-with-animation via o1=false.
      if (seg && seg.fx === s.fx) {
        await postState({ id: s.id, on: true, o1: false });
        return;
      }

      // Otherwise, do a normal segment OFF (does not use Lightbar's virtual power semantics).
      await postState({ id: s.id, on: false });
    }

    async function setBrightnessAbs(bri) {
      const s = selected();
      await postState({ id: s.id, bri: clamp(bri, 0, 255) });
    }

    async function adjustBrightness(delta) {
      const seg = getSegFromState(lastState, selected().id);
      const cur = seg?.bri ?? parseInt(ui.briSlider.value, 10) ?? 128;
      await setBrightnessAbs(cur + delta);
    }

    async function setAnchors(mode) {
      const s = selected();
      const a = DEVICE.anchors[selectedKey];
      const tight = !!ui.tightChk.checked;
      const range = (mode === "top")
        ? (tight ? a.topMin : a.topMax)
        : (tight ? a.sideMin : a.sideMax);
      const c1 = encIdx(range[0], s.len);
      const c2 = encIdx(range[1], s.len);
      const t = currentTuning();
      await postState({ id: s.id, on: true, fx: s.fx, o1: true, ...t, c1, c2 });
      setModeForSide(selectedKey, mode);
      setModeVariantForSide(selectedKey, "saved");
      reflectModeUIForSelected();
    }

    async function setAnchorsFull(mode) {
      const s = selected();
      const a = DEVICE.anchors[selectedKey];
      const range = (mode === "top") ? a.topMax : a.sideMax;
      const c1 = encIdx(range[0], s.len);
      const c2 = encIdx(range[1], s.len);
      const t = currentTuning();
      await postState({ id: s.id, on: true, fx: s.fx, o1: true, ...t, c1, c2 });
      setModeForSide(selectedKey, mode);
      setModeVariantForSide(selectedKey, "full");
      reflectModeUIForSelected();
    }

    async function applyMode(mode) {
      const s = selected();
      if (!lastState) await pollOnce();

      // Remember what we were using in the previous mode for this side before switching.
      const prevMode = modeKeyForSide(selectedKey);
      if (!isFullVariant(selectedKey)) rememberCurrentForSideMode(selectedKey, prevMode);

      // Switch to the target mode.
      setModeForSide(selectedKey, mode);
      setModeVariantForSide(selectedKey, "saved");
      reflectModeUIForSelected();

      const mem = readMem(selectedKey, mode);
      if (mem && typeof mem.c1 === "number" && typeof mem.c2 === "number") {
        const t = currentTuning();
        const payload = {
          id: s.id,
          on: true,
          fx: s.fx,
          o1: true,
          ...t,
          c1: mem.c1,
          c2: mem.c2,
        };
        await postState(payload);
        return;
      }

      // First time in this mode: fall back to the anchor defaults.
      await setAnchors(mode);
    }

    async function applyModeFull(mode) {
      if (!lastState) await pollOnce();

      // Remember what we were using in the previous mode for this side before switching.
      const prevMode = modeKeyForSide(selectedKey);
      if (!isFullVariant(selectedKey)) rememberCurrentForSideMode(selectedKey, prevMode);

      await setAnchorsFull(mode);
    }

    async function adjustSize(deltaSteps) {
      const s = selected();
      if (!lastState) await pollOnce();

      // Any manual size adjustment becomes a saved preference.
      setModeVariantForSide(selectedKey, "saved");
      reflectModeUIForSelected();

      const mode = modeKeyForSide(selectedKey);
      const list = STEP_LISTS?.[selectedKey]?.[mode] || [];
      if (!list.length) return;

      // Determine current range (segment-local), then move one step forward/backward (clamped).
      const cur = currentRangeLocalForSideMode(selectedKey, mode);

      let idx = readStepIndex(selectedKey, mode);
      if (idx == null || idx < 0 || idx >= list.length) {
        idx = bestStepIndexForRange(list, cur.lo, cur.hi);
      } else {
        const [a, b] = list[idx];
        if (a !== cur.lo || b !== cur.hi) idx = bestStepIndexForRange(list, cur.lo, cur.hi);
      }

      const dir = deltaSteps >= 0 ? 1 : -1;
      // Clamp at ends (no wrap-around).
      let next = idx + dir;
      if (next < 0) next = 0;
      if (next >= list.length) next = list.length - 1;
      if (next === idx) return;
      writeStepIndex(selectedKey, mode, next);

      const [lo, hi] = list[next];
      const c1 = encIdx(lo, s.len);
      const c2 = encIdx(hi, s.len);
      await postState({ id: s.id, on: true, fx: s.fx, o1: true, c1, c2 });
    }

    async function setColorRGB(rgbHex) {
      const s = selected();
      const hex = rgbHex.replace("#", "");
      if (hex.length !== 6) return;
      const r = parseInt(hex.slice(0,2), 16);
      const g = parseInt(hex.slice(2,4), 16);
      const b = parseInt(hex.slice(4,6), 16);
      const rgb = [clamp8(r), clamp8(g), clamp8(b), 0];
      await postState({ id: s.id, col: [[rgb[0], rgb[1], rgb[2], 0]] });
      maybeTrackWhite(selectedKey, rgb);
    }

    async function nudgeWarmCool(which) {
      if (!lastState) await pollOnce();
      const dir = (which === "warm") ? +1 : -1;
      const cur = currentColorOrDefault();
      if (!isOnWhiteTrack(cur)) {
        const lw = readLastWhite(selectedKey) || WHITE_REF_WARM;
        await postState({ id: selected().id, col: [lw] });
        return; // A) first press restores white only, no step
      }
      const col = stepWarmerColder(dir, cur);
      await postState({ id: selected().id, col: [col] });
      maybeTrackWhite(selectedKey, col);
      // visual feedback: momentary highlight will be updated on next poll
    }

    // Bind UI
    ui.btnDaniel.addEventListener("click", () => setSelected("daniel"));
    ui.btnGabi.addEventListener("click", () => setSelected("gabi"));
    ui.btnDaniel.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") setSelected("daniel"); });
    ui.btnGabi.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") setSelected("gabi"); });

    ui.btnOn.addEventListener("click", () => safeAction(turnOn));
    ui.btnOff.addEventListener("click", () => safeAction(turnOff));

    ui.btnBriDown.addEventListener("click", () => safeAction(() => adjustBrightness(-15)));
    ui.btnBriUp.addEventListener("click", () => safeAction(() => adjustBrightness(+15)));
    ui.briSlider.addEventListener("input", () => { userAdjustingTuning(); ui.briVal.textContent = briToPct(parseInt(ui.briSlider.value, 10)); });
    ui.briSlider.addEventListener("change", () => safeAction(() => setBrightnessAbs(parseInt(ui.briSlider.value, 10))));

    ui.btnMore.addEventListener("click", () => safeAction(() => adjustSize(+1)));
    ui.btnLess.addEventListener("click", () => safeAction(() => adjustSize(-1)));

    ui.btnTop.addEventListener("click", () => safeAction(() => applyMode("top")));
    ui.btnSide.addEventListener("click", () => safeAction(() => applyMode("side")));
    ui.btnTopFull.addEventListener("click", () => safeAction(() => applyModeFull("top"), { remember: false, persist: false }));
    ui.btnSideFull.addEventListener("click", () => safeAction(() => applyModeFull("side"), { remember: false, persist: false }));

    ui.btnWarm.addEventListener("click", () => safeAction(() => nudgeWarmCool("warm")));
    ui.btnCool.addEventListener("click", () => safeAction(() => nudgeWarmCool("cool")));

    ui.colorPick.addEventListener("input", () => {
      // While the iOS color picker is open, polling should not overwrite the chosen value.
      suppressColorFromStateUntil = Date.now() + 15000;
      setSwatch(ui.colorPick.value);
    });
    // Apply immediately when the picker dialog is closed/confirmed.
    ui.colorPick.addEventListener("change", () => {
      suppressColorFromStateUntil = Date.now() + 2000;
      safeAction(() => setColorRGB(ui.colorPick.value));
    });

    ui.btnAdvanced.addEventListener("click", openAdvanced);
    ui.btnAdvanced.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") openAdvanced(); });
    ui.advBackdrop.addEventListener("click", closeAdvanced);
    ui.advClose.addEventListener("click", closeAdvanced);
    ui.advClose.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") closeAdvanced(); });
    window.addEventListener("keydown", (e) => { if (e.key === "Escape" && !ui.advModal.hidden) closeAdvanced(); });

    const updAdv = () => {
      userAdjustingTuning();
      ui.sxVal.textContent = `sx ${ui.sxSlider.value}`;
      ui.ixVal.textContent = `ix ${ui.ixSlider.value}`;
      ui.c3Val.textContent = `c3 ${ui.c3Slider.value}`;
    };
    ui.sxSlider.addEventListener("input", updAdv);
    ui.ixSlider.addEventListener("input", updAdv);
    ui.c3Slider.addEventListener("input", updAdv);
    ui.sxSlider.addEventListener("change", () => safeAction(applyTuningFromUI));
    ui.ixSlider.addEventListener("change", () => safeAction(applyTuningFromUI));
    ui.c3Slider.addEventListener("change", () => safeAction(applyTuningFromUI));
    ui.o2Chk.addEventListener("change", () => { userAdjustingTuning(); safeAction(applyTuningFromUI); });
    ui.o3Chk.addEventListener("change", () => { userAdjustingTuning(); safeAction(applyTuningFromUI); });

    // Persist toggle (per iOS device/browser). Requires a boot preset to be set in WLED.
    ui.persistChk.checked = (localStorage.getItem(LS_PERSIST_KEY) ?? "1") !== "0";
    ui.persistChk.addEventListener("change", () => {
      localStorage.setItem(LS_PERSIST_KEY, ui.persistChk.checked ? "1" : "0");
      if (ui.persistChk.checked) schedulePersistToBootPreset();
    });

    // Start
    setSelected(selectedKey in DEVICE.segments ? selectedKey : "daniel");
    setSwatch(ui.colorPick.value);
    initBootPresetInfo();
    startPolling();
  })();
  </script>
</body>
</html>

