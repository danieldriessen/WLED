<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="theme-color" content="#0b0f18">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Bedside Remote">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Bedside Remote</title>
  <style>
    :root{
      --bg0:#070a10;
      --bg1:#0b0f18;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.085);
      --text:#e7eefc;
      --muted:rgba(231,238,252,.65);
      --line:rgba(255,255,255,.08);
      --accent:#5aa8ff;
      --accent2:#7cf0c9;
      --danger:#ff5a7b;
      --warn:#ffcc66;
      --shadow: 0 12px 40px rgba(0,0,0,.45);
      --r:18px;
      --tap:54px;
      --font: ui-sans-serif, -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% -10%, rgba(90,168,255,.18), transparent 55%),
        radial-gradient(900px 600px at 90% 10%, rgba(124,240,201,.10), transparent 60%),
        radial-gradient(900px 900px at 40% 110%, rgba(255,90,123,.08), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom) 16px;
    }
    .wrap{max-width:520px;margin:0 auto;padding:18px 0 26px}
    header{display:flex;align-items:flex-start;justify-content:space-between;gap:12px;margin-bottom:14px}
    .title{display:flex;flex-direction:column;gap:4px}
    .title h1{margin:0;font-size:20px;letter-spacing:.2px}
    .title .sub{font-size:13px;color:var(--muted);line-height:1.35}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;border-radius:999px;
      background:rgba(0,0,0,.22);border:1px solid var(--line);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
      font-size:12px;color:var(--muted);white-space:nowrap
    }
    .dot{width:8px;height:8px;border-radius:50%;background:var(--danger)}
    .dot.ok{background:var(--accent2)}
    .dot.warn{background:var(--warn)}

    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      padding:14px;
      margin:12px 0;
      backdrop-filter: blur(10px);
    }
    .seg-toggle{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .seg-btn{
      height:var(--tap);
      border-radius:16px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      color:var(--text);
      font-weight:600;
      letter-spacing:.2px;
      display:flex;align-items:center;justify-content:center;
      position:relative;
      transition:transform .06s ease, background .2s ease, border-color .2s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .seg-btn:active{transform:scale(.99)}
    .seg-btn.sel{
      background:linear-gradient(180deg, rgba(90,168,255,.28), rgba(90,168,255,.12));
      border-color:rgba(90,168,255,.55);
      box-shadow: 0 10px 24px rgba(90,168,255,.16);
    }

    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
    .btn{
      height:var(--tap);
      border-radius:16px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.05);
      color:var(--text);
      font-weight:700;
      letter-spacing:.15px;
      display:flex;align-items:center;justify-content:center;
      gap:10px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .ico{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:22px;
      height:22px;
      border-radius:999px;
      background:rgba(0,0,0,.18);
      border:1px solid var(--line);
      color:var(--muted);
      font-weight:900;
      line-height:1;
      flex:0 0 auto;
    }
    .ico.dot{width:14px;height:14px;border:0}
    .ico.dot.warm{background:linear-gradient(180deg, rgba(255,190,120,.95), rgba(255,120,0,.92)); box-shadow:0 8px 20px rgba(255,140,0,.18)}
    .ico.dot.cool{background:linear-gradient(180deg, rgba(190,245,255,.95), rgba(80,170,255,.92)); box-shadow:0 8px 20px rgba(90,168,255,.18)}
    .btn:active{transform:scale(.99)}
    .btn.primary{
      background:linear-gradient(180deg, rgba(124,240,201,.26), rgba(124,240,201,.10));
      border-color:rgba(124,240,201,.55);
    }
    .btn.danger{
      background:linear-gradient(180deg, rgba(255,90,123,.30), rgba(255,90,123,.10));
      border-color:rgba(255,90,123,.55);
    }
    .btn.ghost{background:rgba(0,0,0,.18)}
    .btn.small{height:44px;border-radius:14px;font-weight:700}
    .btn.sel{border-color:rgba(90,168,255,.6);background:rgba(90,168,255,.16)}
    .row{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:12px 0 6px}
    .row .label{font-weight:700}
    .row .hint{font-size:12px;color:var(--muted)}
    .statusline{font-size:13px;color:var(--muted);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .statusline b{color:var(--text)}

    .bri{
      display:grid;
      grid-template-columns: var(--tap) 1fr var(--tap);
      gap:10px;
      align-items:center;
      margin-top:10px;
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .chip{
      display:inline-flex;align-items:center;justify-content:center;
      min-width:46px;height:32px;padding:0 10px;border-radius:999px;
      background:rgba(0,0,0,.22);border:1px solid var(--line);color:var(--muted);
      font-size:12px;font-weight:700;
    }

    .pwrbar{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:12px}
    .pwrpill{
      height:44px;
      border-radius:16px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      display:flex;align-items:center;justify-content:space-between;
      padding:10px 12px;
      gap:10px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
    }
    .pwrpill.sel{
      border-color:rgba(90,168,255,.55);
      background:linear-gradient(180deg, rgba(90,168,255,.18), rgba(0,0,0,.16));
    }
    .pwrleft{display:flex;align-items:center;gap:10px;min-width:0}
    .pwrname{font-weight:900;letter-spacing:.2px}
    .pwrstate{font-size:12px;color:var(--muted);font-weight:800;white-space:nowrap}
    .pwrdot{width:10px;height:10px;border-radius:50%;background:var(--danger);flex:0 0 auto}
    .pwrdot.on{background:var(--accent2)}
    .pwrdot.anim{background:var(--warn)}

    details{border-top:1px solid var(--line);padding-top:10px;margin-top:10px}
    summary{
      cursor:pointer;list-style:none;display:flex;align-items:center;justify-content:space-between;
      font-weight:800;letter-spacing:.2px;
      padding:10px 0;
    }
    summary::-webkit-details-marker{display:none}
    .adv-grid{display:grid;grid-template-columns:1fr;gap:10px}
    .field{
      background:rgba(0,0,0,.16);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .field .top{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .field .top .k{font-weight:800}
    .field .top .v{font-size:12px;color:var(--muted)}
    .toggle{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
    }
    .toggle input{width:22px;height:22px}
    .footer{margin-top:12px;font-size:12px;color:var(--muted);line-height:1.4}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Bedside Remote</h1>
      </div>
      <div class="pill" id="connPill" aria-live="polite">
        <span class="dot" id="connDot"></span>
        <span id="connText">Connecting…</span>
      </div>
    </header>

    <div class="card">
      <div class="seg-toggle" role="tablist" aria-label="Select bedside">
        <div class="seg-btn" id="btnDaniel" role="tab" tabindex="0">Daniel</div>
        <div class="seg-btn" id="btnGabi" role="tab" tabindex="0">Gabriela</div>
      </div>
    </div>

    <div class="card">
      <div class="pwrbar" aria-label="Bedside status">
        <div class="pwrpill" id="pwrDaniel">
          <div class="pwrleft">
            <span class="pwrdot" id="pwrDanielDot" aria-hidden="true"></span>
            <span class="pwrname">Daniel</span>
          </div>
          <span class="pwrstate" id="pwrDanielState">—</span>
        </div>
        <div class="pwrpill" id="pwrGabi">
          <div class="pwrleft">
            <span class="pwrdot" id="pwrGabiDot" aria-hidden="true"></span>
            <span class="pwrname">Gabriela</span>
          </div>
          <span class="pwrstate" id="pwrGabiState">—</span>
        </div>
      </div>

      <div class="grid2">
        <div class="btn primary" id="btnOn">ON</div>
        <div class="btn danger" id="btnOff">OFF</div>
      </div>

      <div class="row">
        <div class="label">Brightness</div>
        <div class="hint"><span class="mono" id="briVal">—</span></div>
      </div>
      <div class="bri">
        <div class="btn ghost" id="btnBriDown" aria-label="Brightness down">−</div>
        <input type="range" min="0" max="255" value="128" id="briSlider">
        <div class="btn ghost" id="btnBriUp" aria-label="Brightness up">+</div>
      </div>

      <div class="row">
        <div class="label">Size</div>
      </div>
      <div class="grid2">
        <div class="btn" id="btnLess"><span class="ico" aria-hidden="true">−</span>Less LEDs</div>
        <div class="btn" id="btnMore"><span class="ico" aria-hidden="true">+</span>More LEDs</div>
      </div>

      <div class="row">
        <div class="label">Mode</div>
      </div>
      <div class="grid2">
        <div class="btn" id="btnSide"><span class="ico" aria-hidden="true">↕</span>Side</div>
        <div class="btn" id="btnTop"><span class="ico" aria-hidden="true">↔</span>Top</div>
      </div>

      <div class="row">
        <div class="label">White</div>
      </div>
      <div class="grid2">
        <div class="btn" id="btnWarm"><span class="ico dot warm" aria-hidden="true"></span>Warmer</div>
        <div class="btn" id="btnCool"><span class="ico dot cool" aria-hidden="true"></span>Colder</div>
      </div>

      <div class="row">
        <div class="label">Color</div>
      </div>
      <div class="grid2">
        <input class="btn small" id="colorPick" type="color" value="#ffa000" aria-label="Pick color">
        <div class="btn small" id="btnColorApply">Apply</div>
      </div>

      <details>
        <summary>
          Advanced
        </summary>

        <div class="adv-grid">
          <div class="field">
            <div class="top">
              <div class="k">Expand speed</div>
              <div class="v mono" id="sxVal">sx —</div>
            </div>
            <input type="range" min="0" max="255" value="90" id="sxSlider">
          </div>

          <div class="field">
            <div class="top">
              <div class="k">Retract speed</div>
              <div class="v mono" id="ixVal">ix —</div>
            </div>
            <input type="range" min="0" max="255" value="120" id="ixSlider">
          </div>

          <div class="field">
            <div class="top">
              <div class="k">Overlap</div>
              <div class="v mono" id="c3Val">c3 —</div>
            </div>
            <input type="range" min="0" max="31" value="14" id="c3Slider">
            <div class="footer">In WLED, <span class="mono">c3</span> is 0–31. The effect maps it to ~0–80 LEDs overlap.</div>
          </div>

          <div class="field">
            <div class="toggle">
              <div>
                <div style="font-weight:800">Realistic OFF</div>
                <div class="hint">Speed-up + small brightness swell near ground</div>
              </div>
              <input type="checkbox" id="o2Chk" checked>
            </div>
          </div>

          <div class="field">
            <div class="toggle">
              <div>
                <div style="font-weight:800">No animation</div>
                <div class="hint">Instant jump to steady ON/OFF (debug)</div>
              </div>
              <input type="checkbox" id="o3Chk">
            </div>
          </div>

          <div class="field">
            <div class="toggle">
              <div>
                <div style="font-weight:800">Tight mode</div>
                <div class="hint">Use “min” windows for Top/Side buttons</div>
              </div>
              <input type="checkbox" id="tightChk">
            </div>
          </div>

          <div class="field">
            <div class="top">
              <div class="k">Current target</div>
              <div class="v mono" id="c12Val">c1/c2 —</div>
            </div>
            <div class="footer">This page drives <span class="mono">/json/state</span> for the selected segment and uses <span class="mono">o1</span> for OFF-with-animation.</div>
          </div>
        </div>
      </details>
    </div>
  </div>

  <script>
  (() => {
    const $ = (id) => document.getElementById(id);

    // Device contract (current setup on your device)
    const DEVICE = {
      ipHint: location.host || "192.168.2.80",
      segments: {
        daniel: { id: 0, name: "Daniel",   fx: 219, len: 131, groundAtStart: true  },
        gabi:   { id: 1, name: "Gabriela", fx: 218, len: 131, groundAtStart: false },
      },
      // Anchor ranges (segment-local indices, inclusive)
      // Right (Daniel): local == global for 0..130
      // Left (Gabriela): derived by mirror rule then converted to segment-local (global-131)
      anchors: {
        daniel: {
          topMin:  [108,116],
          topMax:  [78,130],
          sideMin: [23,31],
          sideMax: [15,77],
        },
        gabi: {
          topMin:  [14,22],
          topMax:  [0,52],
          sideMin: [99,107],
          sideMax: [53,115],
        }
      }
    };

    const ui = {
      connPill: $("connPill"), connDot: $("connDot"), connText: $("connText"),
      btnDaniel: $("btnDaniel"), btnGabi: $("btnGabi"),
      pwrDaniel: $("pwrDaniel"), pwrGabi: $("pwrGabi"),
      pwrDanielDot: $("pwrDanielDot"), pwrGabiDot: $("pwrGabiDot"),
      pwrDanielState: $("pwrDanielState"), pwrGabiState: $("pwrGabiState"),
      btnOn: $("btnOn"), btnOff: $("btnOff"),
      btnBriDown: $("btnBriDown"), btnBriUp: $("btnBriUp"), briSlider: $("briSlider"), briVal: $("briVal"),
      btnMore: $("btnMore"), btnLess: $("btnLess"),
      btnSide: $("btnSide"), btnTop: $("btnTop"),
      btnWarm: $("btnWarm"), btnCool: $("btnCool"),
      colorPick: $("colorPick"), btnColorApply: $("btnColorApply"),
      sxSlider: $("sxSlider"), ixSlider: $("ixSlider"), c3Slider: $("c3Slider"),
      sxVal: $("sxVal"), ixVal: $("ixVal"), c3Val: $("c3Val"),
      o2Chk: $("o2Chk"), o3Chk: $("o3Chk"), tightChk: $("tightChk"),
      c12Val: $("c12Val"),
    };

    const LS_KEY = "bedsideRemote.selected";
    const LS_MODE_PREFIX = "bedsideRemote.mode.";
    const LS_MEM_PREFIX  = "bedsideRemote.mem.";
    const LS_STEP_PREFIX = "bedsideRemote.step.";
    let selectedKey = localStorage.getItem(LS_KEY) || "daniel";
    let selectedModeBySide = {
      daniel: localStorage.getItem(LS_MODE_PREFIX + "daniel") || "side",
      gabi:   localStorage.getItem(LS_MODE_PREFIX + "gabi")   || "side",
    };
    let lastState = null;
    let pollTimer = null;
    let busy = false;
    let suppressTuningFromStateUntil = 0;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const briToPct = (bri) => `${Math.round(clamp(bri ?? 0, 0, 255) * 100 / 255)} %`;
    const encIdx = (idx, len) => {
      if (len <= 1) return 0;
      return Math.round(idx * 255 / (len - 1));
    };
    const decIdx = (u8, len) => {
      if (len <= 1) return 0;
      return Math.round(u8 * (len - 1) / 255);
    };

    // Canonical "More/Less LEDs" behavior:
    // step through a fixed ordered list of inclusive ranges per side+mode (with wrap-around).
    function genPhaseSym(a0, b0, steps) {
      const out = [];
      for (let k = 0; k < steps; k++) out.push([a0 - k, b0 + k]);
      return out;
    }
    function genPhaseFixedHi(hi, aStart, aEndInclusive) {
      const out = [];
      for (let a = aStart; a >= aEndInclusive; a--) out.push([a, hi]);
      return out;
    }
    function genPhaseFixedLo(lo, bStart, bEndInclusive) {
      const out = [];
      for (let b = bStart; b <= bEndInclusive; b++) out.push([lo, b]);
      return out;
    }
    function toLocalRanges(rangesGlobal, sideKey) {
      const off = (sideKey === "gabi") ? 131 : 0;
      const len = DEVICE.segments[sideKey].len;
      return rangesGlobal.map(([a, b]) => {
        const lo = clamp(a - off, 0, len - 1);
        const hi = clamp(b - off, 0, len - 1);
        return [Math.min(lo, hi), Math.max(lo, hi)];
      });
    }
    const STEP_LISTS = (() => {
      // Global step lists (inclusive indices). These match the canonical spec in your prompt.
      const rightSideGlobal = [
        ...genPhaseSym(23, 31, 9),
        ...genPhaseFixedLo(15, 40, 77),
      ];
      const rightTopGlobal = [
        ...genPhaseSym(108, 116, 15),
        ...genPhaseFixedHi(130, 93, 78),
      ];
      const leftSideGlobal = [
        ...genPhaseSym(230, 238, 9),
        ...genPhaseFixedHi(246, 221, 184),
      ];
      const leftTopGlobal = [
        ...genPhaseSym(145, 153, 15),
        ...genPhaseFixedLo(131, 168, 183),
      ];

      return {
        daniel: {
          side: toLocalRanges(rightSideGlobal, "daniel"),
          top:  toLocalRanges(rightTopGlobal,  "daniel"),
        },
        gabi: {
          side: toLocalRanges(leftSideGlobal, "gabi"),
          top:  toLocalRanges(leftTopGlobal,  "gabi"),
        }
      };
    })();

    function selected() {
      return DEVICE.segments[selectedKey];
    }

    function modeKeyForSide(sideKey) {
      return selectedModeBySide[sideKey] || "side";
    }

    function setModeForSide(sideKey, mode) {
      selectedModeBySide[sideKey] = mode;
      localStorage.setItem(LS_MODE_PREFIX + sideKey, mode);
    }

    function memKey(sideKey, mode) {
      return `${LS_MEM_PREFIX}${sideKey}.${mode}`;
    }
    function stepKey(sideKey, mode) {
      return `${LS_STEP_PREFIX}${sideKey}.${mode}`;
    }

    function readMem(sideKey, mode) {
      try {
        const raw = localStorage.getItem(memKey(sideKey, mode));
        return raw ? JSON.parse(raw) : null;
      } catch {
        return null;
      }
    }

    function writeMem(sideKey, mode, obj) {
      try {
        localStorage.setItem(memKey(sideKey, mode), JSON.stringify(obj));
      } catch {
        // ignore quota / serialization errors
      }
    }
    function readStepIndex(sideKey, mode) {
      const raw = localStorage.getItem(stepKey(sideKey, mode));
      const n = raw == null ? NaN : parseInt(raw, 10);
      return Number.isFinite(n) ? n : null;
    }
    function writeStepIndex(sideKey, mode, idx) {
      try { localStorage.setItem(stepKey(sideKey, mode), String(idx)); } catch {}
    }

    function segPrimaryCol(seg) {
      const c = seg?.col?.[0];
      if (!Array.isArray(c) || c.length < 3) return null;
      return [c[0] ?? 0, c[1] ?? 0, c[2] ?? 0, c[3] ?? 0].map(v => clamp(parseInt(v, 10) || 0, 0, 255));
    }

    function currentColorOrDefault() {
      const seg = getSegFromState(lastState, selected().id);
      return segPrimaryCol(seg) || [255,160,0,0];
    }

    function clamp8(v) { return clamp(v|0, 0, 255); }

    function mix(a, b, t01) {
      return clamp8(Math.round(a + (b - a) * t01));
    }

    function stepWarmerColder(dir /* -1 colder, +1 warmer */) {
      // Use a small step towards a warm/cool reference white.
      // This keeps user-chosen brightness and only nudges hue/temperature.
      const warmRef = [255,160,0,0];
      const coolRef = [170,215,255,0];
      const step = 0.18; // per-tap blend factor

      const cur = currentColorOrDefault();
      const ref = (dir > 0) ? warmRef : coolRef;
      const out = [
        mix(cur[0], ref[0], step),
        mix(cur[1], ref[1], step),
        mix(cur[2], ref[2], step),
        0
      ];
      return out;
    }

    function snapshotForLightbar(seg) {
      if (!seg) return null;
      if (typeof seg.c1 !== "number" || typeof seg.c2 !== "number") return null;
      const col0 = segPrimaryCol(seg);
      return {
        bri: typeof seg.bri === "number" ? clamp(seg.bri, 1, 255) : null,
        col: col0,
        c1: seg.c1,
        c2: seg.c2,
      };
    }

    function currentRangeLocalForSideMode(sideKey, mode) {
      const segId = DEVICE.segments[sideKey]?.id;
      const fxId  = DEVICE.segments[sideKey]?.fx;
      const len   = DEVICE.segments[sideKey]?.len ?? 1;
      const list  = STEP_LISTS?.[sideKey]?.[mode] || [];

      const seg = getSegFromState(lastState, segId);
      if (seg && seg.fx === fxId && typeof seg.c1 === "number" && typeof seg.c2 === "number") {
        const a = decIdx(seg.c1, len);
        const b = decIdx(seg.c2, len);
        return { lo: Math.min(a,b), hi: Math.max(a,b) };
      }

      const mem = readMem(sideKey, mode);
      if (mem && typeof mem.c1 === "number" && typeof mem.c2 === "number") {
        const a = decIdx(mem.c1, len);
        const b = decIdx(mem.c2, len);
        return { lo: Math.min(a,b), hi: Math.max(a,b) };
      }

      if (list.length) {
        const [lo, hi] = list[0];
        return { lo, hi };
      }

      return { lo: 0, hi: 0 };
    }

    function bestStepIndexForRange(list, lo, hi) {
      if (!list.length) return 0;
      let best = 0;
      let bestScore = Infinity;
      for (let i = 0; i < list.length; i++) {
        const [a, b] = list[i];
        if (a === lo && b === hi) return i;
        const score = Math.abs(a - lo) + Math.abs(b - hi);
        if (score < bestScore) { bestScore = score; best = i; }
      }
      return best;
    }

    function rememberCurrentForSideMode(sideKey, mode) {
      if (!lastState) return;
      const segId = DEVICE.segments[sideKey]?.id;
      const fxId  = DEVICE.segments[sideKey]?.fx;
      const seg = getSegFromState(lastState, segId);
      if (!seg || seg.fx !== fxId) return; // only remember Lightbar settings for Lightbar modes
      const snap = snapshotForLightbar(seg);
      if (!snap) return;
      writeMem(sideKey, mode, snap);
    }

    function reflectModeUIForSelected() {
      const mode = modeKeyForSide(selectedKey);
      ui.btnTop.classList.toggle("sel", mode === "top");
      ui.btnSide.classList.toggle("sel", mode === "side");
    }

    function setSelected(key) {
      // Before switching, remember the last-used state into the current mode of the previous side.
      if (key !== selectedKey) {
        rememberCurrentForSideMode(selectedKey, modeKeyForSide(selectedKey));
      }

      selectedKey = key;
      localStorage.setItem(LS_KEY, key);
      ui.btnDaniel.classList.toggle("sel", key === "daniel");
      ui.btnGabi.classList.toggle("sel", key === "gabi");
      ui.pwrDaniel.classList.toggle("sel", key === "daniel");
      ui.pwrGabi.classList.toggle("sel", key === "gabi");
      reflectModeUIForSelected();
      renderFromState(lastState);
    }

    async function postState(segObj) {
      const payload = { seg: [segObj] };
      const res = await fetch("/json/state", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json().catch(() => ({}));
    }

    function conn(ok, txt, level="ok") {
      ui.connDot.classList.toggle("ok", ok);
      ui.connDot.classList.toggle("warn", level==="warn" && ok);
      ui.connText.textContent = txt;
    }

    function getSegFromState(state, segId) {
      if (!state || !state.seg) return null;
      return state.seg.find(s => s.id === segId) || null;
    }

    function renderFromState(state) {
      if (!state) return;
      const sSel = selected();
      const segSel = getSegFromState(state, sSel.id);
      if (!segSel) return;

      const now = Date.now();
      const allowTuningFromState = now >= suppressTuningFromStateUntil;
      const notActive = (el) => document.activeElement !== el;

      // Brightness
      if (allowTuningFromState && notActive(ui.briSlider) && typeof segSel.bri === "number") {
        ui.briSlider.value = segSel.bri;
      }
      ui.briVal.textContent = briToPct(parseInt(ui.briSlider.value, 10));

      // Advanced tuning (sx/ix/c3 + o2/o3)
      if (allowTuningFromState && notActive(ui.sxSlider) && typeof segSel.sx === "number") ui.sxSlider.value = segSel.sx;
      if (allowTuningFromState && notActive(ui.ixSlider) && typeof segSel.ix === "number") ui.ixSlider.value = segSel.ix;
      if (allowTuningFromState && notActive(ui.c3Slider) && typeof segSel.c3 === "number") ui.c3Slider.value = segSel.c3;

      ui.sxVal.textContent = `sx ${ui.sxSlider.value}`;
      ui.ixVal.textContent = `ix ${ui.ixSlider.value}`;
      ui.c3Val.textContent = `c3 ${ui.c3Slider.value}`;
      ui.c12Val.textContent = `c1 ${segSel.c1 ?? "—"} • c2 ${segSel.c2 ?? "—"}`;

      if (allowTuningFromState && notActive(ui.o2Chk)) ui.o2Chk.checked = !!segSel.o2;
      if (allowTuningFromState && notActive(ui.o3Chk)) ui.o3Chk.checked = !!segSel.o3;

      function setPwrUI(sideKey, pillEl, dotEl, stateEl) {
        const cfg = DEVICE.segments[sideKey];
        const seg = getSegFromState(state, cfg.id);
        if (!seg) {
          dotEl.classList.remove("on","anim");
          stateEl.textContent = "—";
          return;
        }
        const isLightbar = (seg.fx === cfg.fx);
        const on = !!seg.on;
        const desired = !!seg.o1;
        let label = "OFF";
        dotEl.classList.remove("on","anim");

        if (isLightbar) {
          if (on && desired) { label = "ON"; dotEl.classList.add("on"); }
          else if (on && !desired) { label = "OFF (anim)"; dotEl.classList.add("anim"); }
          else { label = "OFF"; }
        } else {
          if (on) { label = "ON"; dotEl.classList.add("on"); }
          else { label = "OFF"; }
        }
        stateEl.textContent = label;
      }

      setPwrUI("daniel", ui.pwrDaniel, ui.pwrDanielDot, ui.pwrDanielState);
      setPwrUI("gabi",   ui.pwrGabi,   ui.pwrGabiDot,   ui.pwrGabiState);
    }

    async function pollOnce() {
      try {
        const res = await fetch("/json/state", { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        lastState = await res.json();
        conn(true, "Connected", "ok");
        renderFromState(lastState);
      } catch (e) {
        conn(false, "Offline");
      }
    }

    function startPolling() {
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(pollOnce, 900);
      pollOnce();
    }

    async function safeAction(fn) {
      if (busy) return;
      busy = true;
      try { await fn(); }
      finally { busy = false; }
      await pollOnce();
      // Keep per-mode memory updated for the selected side, based on the current selected mode.
      rememberCurrentForSideMode(selectedKey, modeKeyForSide(selectedKey));
    }

    function currentTuning() {
      return {
        sx: parseInt(ui.sxSlider.value, 10),
        ix: parseInt(ui.ixSlider.value, 10),
        c3: parseInt(ui.c3Slider.value, 10),
        o2: !!ui.o2Chk.checked,
        o3: !!ui.o3Chk.checked,
      };
    }

    function userAdjustingTuning() {
      suppressTuningFromStateUntil = Date.now() + 1400;
    }

    async function applyTuningFromUI() {
      const s = selected();
      const t = currentTuning();
      await postState({ id: s.id, ...t });
    }

    function currentC12FromStateOrDefault() {
      const seg = getSegFromState(lastState, selected().id);
      if (seg && typeof seg.c1 === "number" && typeof seg.c2 === "number") return { c1: seg.c1, c2: seg.c2 };
      return { c1: 128, c2: 128 };
    }

    async function turnOn() {
      const s = selected();
      if (!lastState) await pollOnce(); // ensure we restore the latest per-segment state

      const seg = getSegFromState(lastState, s.id);

      // Restore last-used state:
      // - Always turn the segment ON (seg.on=true)
      // - Only use the Lightbar virtual power contract (o1=true) if the segment is currently on the Lightbar effect.
      // - If the segment isn't set up yet (missing in state), initialize it to the expected Lightbar effect for this side.
      if (!seg) {
        const { c1, c2 } = currentC12FromStateOrDefault();
        const t = currentTuning();
        await postState({ id: s.id, on: true, fx: s.fx, o1: true, ...t, c1, c2 });
        return;
      }

      if (seg.fx === s.fx) {
        await postState({ id: s.id, on: true, o1: true });
        return;
      }

      // Different effect active -> do not force Lightbar or its o1 semantics.
      await postState({ id: s.id, on: true });
    }

    async function turnOff() {
      const s = selected();
      if (!lastState) await pollOnce();

      const seg = getSegFromState(lastState, s.id);

      // If the segment is running the Lightbar effect, request OFF-with-animation via o1=false.
      if (seg && seg.fx === s.fx) {
        await postState({ id: s.id, on: true, o1: false });
        return;
      }

      // Otherwise, do a normal segment OFF (does not use Lightbar's virtual power semantics).
      await postState({ id: s.id, on: false });
    }

    async function setBrightnessAbs(bri) {
      const s = selected();
      await postState({ id: s.id, bri: clamp(bri, 0, 255) });
    }

    async function adjustBrightness(delta) {
      const seg = getSegFromState(lastState, selected().id);
      const cur = seg?.bri ?? parseInt(ui.briSlider.value, 10) ?? 128;
      await setBrightnessAbs(cur + delta);
    }

    async function setAnchors(mode) {
      const s = selected();
      const a = DEVICE.anchors[selectedKey];
      const tight = !!ui.tightChk.checked;
      const range = (mode === "top")
        ? (tight ? a.topMin : a.topMax)
        : (tight ? a.sideMin : a.sideMax);
      const c1 = encIdx(range[0], s.len);
      const c2 = encIdx(range[1], s.len);
      const t = currentTuning();
      await postState({ id: s.id, on: true, fx: s.fx, o1: true, ...t, c1, c2 });
      setModeForSide(selectedKey, mode);
      reflectModeUIForSelected();
    }

    async function applyMode(mode) {
      const s = selected();
      if (!lastState) await pollOnce();

      // Remember what we were using in the previous mode for this side before switching.
      const prevMode = modeKeyForSide(selectedKey);
      rememberCurrentForSideMode(selectedKey, prevMode);

      // Switch to the target mode.
      setModeForSide(selectedKey, mode);
      reflectModeUIForSelected();

      const mem = readMem(selectedKey, mode);
      if (mem && typeof mem.c1 === "number" && typeof mem.c2 === "number") {
        const t = currentTuning();
        const payload = {
          id: s.id,
          on: true,
          fx: s.fx,
          o1: true,
          ...t,
          c1: mem.c1,
          c2: mem.c2,
        };
        if (typeof mem.bri === "number") payload.bri = clamp(mem.bri, 1, 255);
        if (Array.isArray(mem.col) && mem.col.length >= 3) payload.col = [[mem.col[0], mem.col[1], mem.col[2], mem.col[3] ?? 0]];
        await postState(payload);
        return;
      }

      // First time in this mode: fall back to the anchor defaults.
      await setAnchors(mode);
    }

    async function adjustSize(deltaSteps) {
      const s = selected();
      if (!lastState) await pollOnce();

      const mode = modeKeyForSide(selectedKey);
      const list = STEP_LISTS?.[selectedKey]?.[mode] || [];
      if (!list.length) return;

      // Determine current range (segment-local), then move one step forward/backward with wrap-around.
      const cur = currentRangeLocalForSideMode(selectedKey, mode);

      let idx = readStepIndex(selectedKey, mode);
      if (idx == null || idx < 0 || idx >= list.length) {
        idx = bestStepIndexForRange(list, cur.lo, cur.hi);
      } else {
        const [a, b] = list[idx];
        if (a !== cur.lo || b !== cur.hi) idx = bestStepIndexForRange(list, cur.lo, cur.hi);
      }

      const dir = deltaSteps >= 0 ? 1 : -1;
      const next = (idx + dir + list.length) % list.length;
      writeStepIndex(selectedKey, mode, next);

      const [lo, hi] = list[next];
      const c1 = encIdx(lo, s.len);
      const c2 = encIdx(hi, s.len);
      await postState({ id: s.id, on: true, fx: s.fx, o1: true, c1, c2 });
    }

    async function setColorRGB(rgbHex) {
      const s = selected();
      const hex = rgbHex.replace("#", "");
      if (hex.length !== 6) return;
      const r = parseInt(hex.slice(0,2), 16);
      const g = parseInt(hex.slice(2,4), 16);
      const b = parseInt(hex.slice(4,6), 16);
      await postState({ id: s.id, col: [[r,g,b,0]] });
    }

    async function nudgeWarmCool(which) {
      if (!lastState) await pollOnce();
      const dir = (which === "warm") ? +1 : -1;
      const col = stepWarmerColder(dir);
      await postState({ id: selected().id, col: [col] });
      // visual feedback: momentary highlight will be updated on next poll
    }

    // Bind UI
    ui.btnDaniel.addEventListener("click", () => setSelected("daniel"));
    ui.btnGabi.addEventListener("click", () => setSelected("gabi"));
    ui.btnDaniel.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") setSelected("daniel"); });
    ui.btnGabi.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") setSelected("gabi"); });

    ui.btnOn.addEventListener("click", () => safeAction(turnOn));
    ui.btnOff.addEventListener("click", () => safeAction(turnOff));

    ui.btnBriDown.addEventListener("click", () => safeAction(() => adjustBrightness(-15)));
    ui.btnBriUp.addEventListener("click", () => safeAction(() => adjustBrightness(+15)));
    ui.briSlider.addEventListener("input", () => { userAdjustingTuning(); ui.briVal.textContent = briToPct(parseInt(ui.briSlider.value, 10)); });
    ui.briSlider.addEventListener("change", () => safeAction(() => setBrightnessAbs(parseInt(ui.briSlider.value, 10))));

    ui.btnMore.addEventListener("click", () => safeAction(() => adjustSize(+1)));
    ui.btnLess.addEventListener("click", () => safeAction(() => adjustSize(-1)));

    ui.btnTop.addEventListener("click", () => safeAction(() => applyMode("top")));
    ui.btnSide.addEventListener("click", () => safeAction(() => applyMode("side")));

    ui.btnWarm.addEventListener("click", () => safeAction(() => nudgeWarmCool("warm")));
    ui.btnCool.addEventListener("click", () => safeAction(() => nudgeWarmCool("cool")));

    ui.btnColorApply.addEventListener("click", () => safeAction(() => setColorRGB(ui.colorPick.value)));

    const updAdv = () => {
      userAdjustingTuning();
      ui.sxVal.textContent = `sx ${ui.sxSlider.value}`;
      ui.ixVal.textContent = `ix ${ui.ixSlider.value}`;
      ui.c3Val.textContent = `c3 ${ui.c3Slider.value}`;
    };
    ui.sxSlider.addEventListener("input", updAdv);
    ui.ixSlider.addEventListener("input", updAdv);
    ui.c3Slider.addEventListener("input", updAdv);
    ui.sxSlider.addEventListener("change", () => safeAction(applyTuningFromUI));
    ui.ixSlider.addEventListener("change", () => safeAction(applyTuningFromUI));
    ui.c3Slider.addEventListener("change", () => safeAction(applyTuningFromUI));
    ui.o2Chk.addEventListener("change", () => { userAdjustingTuning(); safeAction(applyTuningFromUI); });
    ui.o3Chk.addEventListener("change", () => { userAdjustingTuning(); safeAction(applyTuningFromUI); });

    // Start
    setSelected(selectedKey in DEVICE.segments ? selectedKey : "daniel");
    startPolling();
  })();
  </script>
</body>
</html>

